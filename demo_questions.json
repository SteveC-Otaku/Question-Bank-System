[
  {
    "title": "JavaScript基础 - 变量声明",
    "content": "在JavaScript中，使用let关键字声明的变量具有什么特性？",
    "type": "multiple_choice",
    "subject": "JavaScript编程",
    "difficulty": "easy",
    "options": [
      {"text": "块级作用域", "isCorrect": true},
      {"text": "函数作用域", "isCorrect": false},
      {"text": "全局作用域", "isCorrect": false},
      {"text": "没有作用域限制", "isCorrect": false}
    ],
    "answer": {
      "explanation": "let关键字声明的变量具有块级作用域，只在声明它的代码块内有效。",
      "detailedSolution": "let是ES6引入的变量声明方式，具有以下特性：\n1. 块级作用域\n2. 不存在变量提升\n3. 不允许重复声明\n4. 暂时性死区",
      "keyPoints": ["块级作用域", "ES6特性", "变量提升", "暂时性死区"],
      "difficulty": "easy"
    },
    "tags": ["javascript", "变量", "ES6", "基础"],
    "createdBy": "teacher"
  },
  {
    "title": "Python函数 - 递归计算阶乘",
    "content": "编写一个Python函数，使用递归方法计算一个正整数的阶乘。函数应该能够处理输入验证并返回正确的结果。",
    "type": "programming",
    "subject": "Python编程",
    "difficulty": "medium",
    "programmingLanguage": "python",
    "testCases": [
      {
        "input": "5",
        "expectedOutput": "120",
        "description": "计算5的阶乘"
      },
      {
        "input": "0",
        "expectedOutput": "1",
        "description": "计算0的阶乘"
      },
      {
        "input": "3",
        "expectedOutput": "6",
        "description": "计算3的阶乘"
      }
    ],
    "answer": {
      "explanation": "使用递归方法，基本情况是n=0或n=1时返回1，否则返回n乘以(n-1)的阶乘。",
      "detailedSolution": "def factorial(n):\n    if n < 0:\n        return 'Error: 负数没有阶乘'\n    elif n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)",
      "keyPoints": ["递归", "基本情况", "输入验证", "数学概念"],
      "difficulty": "medium"
    },
    "tags": ["python", "递归", "函数", "数学"],
    "createdBy": "teacher"
  },
  {
    "title": "数据库设计原则",
    "content": "在数据库设计中，第一范式（1NF）要求什么？",
    "type": "multiple_choice",
    "subject": "数据库设计",
    "difficulty": "medium",
    "options": [
      {"text": "消除非主属性对主键的部分函数依赖", "isCorrect": false},
      {"text": "确保每个字段都是原子性的，不可再分", "isCorrect": true},
      {"text": "消除传递函数依赖", "isCorrect": false},
      {"text": "确保数据完整性", "isCorrect": false}
    ],
    "answer": {
      "explanation": "第一范式要求表中的每个字段都是原子性的，即不可再分解的最小数据单位。",
      "detailedSolution": "第一范式（1NF）是关系数据库设计的基础，要求：\n1. 每个字段都是原子性的\n2. 没有重复的组\n3. 每个字段都有明确的数据类型",
      "keyPoints": ["原子性", "不可再分", "基础范式", "数据规范化"],
      "difficulty": "medium"
    },
    "tags": ["数据库", "范式", "设计原则", "规范化"],
    "createdBy": "teacher"
  },
  {
    "title": "HTTP状态码含义",
    "content": "HTTP状态码404表示什么？",
    "type": "true_false",
    "subject": "Web开发",
    "difficulty": "easy",
    "options": [
      {"text": "True", "isCorrect": true},
      {"text": "False", "isCorrect": false}
    ],
    "answer": {
      "explanation": "404状态码表示'Not Found'，即请求的资源在服务器上不存在。",
      "detailedSolution": "HTTP 404错误表示：\n- 请求的页面或资源不存在\n- 可能是URL拼写错误\n- 或者资源已被移动或删除",
      "keyPoints": ["404", "Not Found", "HTTP状态码", "错误处理"],
      "difficulty": "easy"
    },
    "tags": ["HTTP", "状态码", "Web开发", "错误处理"],
    "createdBy": "teacher"
  },
  {
    "title": "算法复杂度分析",
    "content": "解释什么是时间复杂度和空间复杂度，并说明为什么在算法设计中需要考虑这两个因素。",
    "type": "essay",
    "subject": "算法与数据结构",
    "difficulty": "hard",
    "correctAnswer": "时间复杂度衡量算法执行时间随输入规模增长的变化趋势，空间复杂度衡量算法所需内存空间随输入规模增长的变化趋势。在算法设计中需要考虑这两个因素，因为它们直接影响程序的性能和资源消耗。",
    "answer": {
      "explanation": "算法复杂度分析是评估算法效率的重要工具，帮助开发者选择最优的解决方案。",
      "detailedSolution": "时间复杂度分析：\n1. 大O表示法\n2. 最好、最坏、平均情况\n3. 常见复杂度：O(1), O(n), O(n²), O(log n)\n\n空间复杂度分析：\n1. 额外空间需求\n2. 递归调用栈空间\n3. 临时变量空间",
      "keyPoints": ["时间复杂度", "空间复杂度", "大O表示法", "算法优化"],
      "difficulty": "hard"
    },
    "tags": ["算法", "复杂度", "性能分析", "计算机科学"],
    "createdBy": "teacher"
  },
  {
    "title": "Java面向对象编程",
    "content": "在Java中，什么是封装？请举例说明。",
    "type": "short_answer",
    "subject": "Java编程",
    "difficulty": "medium",
    "correctAnswer": "封装是面向对象编程的三大特性之一，它将数据和方法绑定在一起，隐藏内部实现细节，只提供必要的接口。例如，一个BankAccount类可以封装账户余额，只提供deposit和withdraw方法来操作余额。",
    "answer": {
      "explanation": "封装通过访问修饰符（private、public、protected）来控制对类成员的访问。",
      "detailedSolution": "封装的特点：\n1. 数据隐藏\n2. 访问控制\n3. 接口设计\n4. 信息保护\n\n示例：\npublic class BankAccount {\n    private double balance;\n    \n    public void deposit(double amount) {\n        if (amount > 0) balance += amount;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}",
      "keyPoints": ["封装", "访问修饰符", "数据隐藏", "接口设计"],
      "difficulty": "medium"
    },
    "tags": ["java", "面向对象", "封装", "编程概念"],
    "createdBy": "teacher"
  },
  {
    "title": "CSS选择器优先级",
    "content": "在CSS中，以下哪个选择器的优先级最高？",
    "type": "multiple_choice",
    "subject": "前端开发",
    "difficulty": "medium",
    "options": [
      {"text": "类选择器 (.class)", "isCorrect": false},
      {"text": "ID选择器 (#id)", "isCorrect": true},
      {"text": "元素选择器 (div)", "isCorrect": false},
      {"text": "伪类选择器 (:hover)", "isCorrect": false}
    ],
    "answer": {
      "explanation": "ID选择器的优先级最高，其次是类选择器，最后是元素选择器。",
      "detailedSolution": "CSS选择器优先级（从高到低）：\n1. !important\n2. 内联样式\n3. ID选择器 (#id)\n4. 类选择器 (.class)\n5. 元素选择器 (div)\n6. 通配符选择器 (*)",
      "keyPoints": ["CSS优先级", "选择器", "样式冲突", "前端开发"],
      "difficulty": "medium"
    },
    "tags": ["CSS", "选择器", "优先级", "前端开发"],
    "createdBy": "teacher"
  },
  {
    "title": "Git版本控制",
    "content": "Git中的merge和rebase有什么区别？",
    "type": "essay",
    "subject": "版本控制",
    "difficulty": "hard",
    "correctAnswer": "Merge将两个分支的历史合并，创建一个新的合并提交，保留两个分支的完整历史。Rebase将当前分支的提交重新应用到目标分支上，创建线性的提交历史。Merge适合合并功能分支，rebase适合保持主分支历史的整洁。",
    "answer": {
      "explanation": "选择merge还是rebase取决于团队的工作流程和项目需求。",
      "detailedSolution": "Merge特点：\n- 保留完整历史\n- 创建合并提交\n- 适合公共分支\n\nRebase特点：\n- 线性历史\n- 重写提交历史\n- 适合本地分支整理",
      "keyPoints": ["Git", "版本控制", "分支管理", "工作流程"],
      "difficulty": "hard"
    },
    "tags": ["Git", "版本控制", "分支管理", "开发工具"],
    "createdBy": "teacher"
  },
  {
    "title": "网络协议基础",
    "content": "TCP协议是面向连接的协议。",
    "type": "true_false",
    "subject": "计算机网络",
    "difficulty": "easy",
    "options": [
      {"text": "True", "isCorrect": true},
      {"text": "False", "isCorrect": false}
    ],
    "answer": {
      "explanation": "TCP（传输控制协议）是面向连接的协议，在数据传输前需要建立连接。",
      "detailedSolution": "TCP协议特点：\n1. 面向连接\n2. 可靠传输\n3. 流量控制\n4. 拥塞控制\n5. 有序传输",
      "keyPoints": ["TCP", "面向连接", "可靠传输", "网络协议"],
      "difficulty": "easy"
    },
    "tags": ["网络协议", "TCP", "计算机网络", "传输层"],
    "createdBy": "teacher"
  },
  {
    "title": "数据结构 - 栈的应用",
    "content": "编写一个函数来检查字符串中的括号是否匹配。使用栈数据结构实现。",
    "type": "programming",
    "subject": "数据结构",
    "difficulty": "medium",
    "programmingLanguage": "java",
    "testCases": [
      {
        "input": "\"((()))\"",
        "expectedOutput": "true",
        "description": "匹配的括号"
      },
      {
        "input": "\"(()\"",
        "expectedOutput": "false",
        "description": "不匹配的括号"
      },
      {
        "input": "\")\"",
        "expectedOutput": "false",
        "description": "单个右括号"
      }
    ],
    "answer": {
      "explanation": "使用栈来跟踪左括号，遇到右括号时检查栈顶是否匹配。",
      "detailedSolution": "public boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.isEmpty()) return false;\n            stack.pop();\n        }\n    }\n    return stack.isEmpty();\n}",
      "keyPoints": ["栈", "括号匹配", "数据结构", "算法"],
      "difficulty": "medium"
    },
    "tags": ["数据结构", "栈", "算法", "Java"],
    "createdBy": "teacher"
  }
] 